#include <msp430.h> 

/*
 * main.cpp
 */

#include "CC1101.h"
#include "Pinouts.h"
#include "Registers.h"
#include "debug.h"

#define SW2FLAG 		0x01			//flag for SW2 being pressed
#define GDO0FLAG		0x02			//flag for GDO0 (running in nIRQ mode) pin going low

char txBuffer[4];
char rxBuffer[4];
unsigned char FLAGS = 0;   //char to hold flags generated by ISR

unsigned int i;

int main(void)
{
    WDTCTL = WDTPW | WDTHOLD;	// Stop watchdog timer

    UARTInit();					//for debug purposes
    cc1101.Init();
    cc1101.SetReceive();

    //Configure ports -- switch inputs, LEDs, GDO0 to RX packet info from CC1101
    SW_PxIES = ~SW2;			//Int on falling edge
    SW_PxIFG &= ~(SW2);			//Clr flags
    SW_PxIE = SW2;				//Activate enables
    SW_PxREN |= SW2;			//enable pullup/pulldown resistor
    SW_PxOUT |= SW2;			//pullup the resistor
    LED_PxOUT &= ~(LED1); 		//Set LED1 off
    LED_PxDIR = LED1; 			//set led1 to output

    GDO0_PxIES |= GDO0_PIN;       // Int on falling edge (end of pkt)
    GDO0_PxREN |= GDO0_PIN;		  //enable pullup/pulldown resistor
    GDO0_PxOUT |= GDO0_PIN;		  //now pull resistor up
    GDO0_PxIFG &= ~GDO0_PIN;      // Clear flag
    GDO0_PxIE |= GDO0_PIN;        // Enable int on end of packet
    unsigned char STATE = 1;	  //default state is 1
	while(1)
	{
		switch(STATE)
		{

			case 1:		//this is the idle state
			 __bis_SR_register(LPM3_bits + GIE);

			 //
			 if(FLAGS & SW2FLAG)
			 {
				 STATE = 2;
				 FLAGS &= ~SW2FLAG;
			 }
			 else if (FLAGS & GDO0FLAG)
			 {
				 STATE = 3;
				 FLAGS &= ~GDO0FLAG;
			 }
				 break;
			case 2:
			{
				//temporarily disable GDO0 interrupt
				GDO0_PxIE &= ~GDO0_PIN;

				char size = 3;			//this is the size of the entire packet being sent, including the size byte
				txBuffer[0] = 2;		//this is the size byte (it lets the receiver know how many bytes are following)
				txBuffer[1] = 0x01;		//first byte
				txBuffer[2] = 0xAA;		//second byte
				cc1101.SendPacket(txBuffer, size);
				STATE = 1;				//return to IDLE state
				GDO0_PxIFG &= ~GDO0_PIN;      // Clear flag
				GDO0_PxIE |= GDO0_PIN;        // Enable int on end of packet
				FLAGS = 0;					//clear flag buffer
				break;
			}
			case 3:
			{
				//temporarily disable GDO0 interrupt
				GDO0_PxIE &= ~GDO0_PIN;
				char len = 4;
				if(cc1101.ReceivePacket(rxBuffer, &len))
				{
					short s = cc1101.GetRSSI();
					LED_PxOUT ^= LED1;
					cc1101.SetReceive();
				}
				else
				{
					//CRC did not check out or buffer was too small to hold received packet
				}
				STATE = 1;		//return to idle state
				GDO0_PxIFG &= ~GDO0_PIN;      // Clear flag
				GDO0_PxIE |= GDO0_PIN;        // Enable int on end of packet
				FLAGS = 0;						//clear flag buffer
				break;
			}
		}
	}
}




#pragma vector = PORT1_VECTOR
__interrupt void PORT1ISR(void)
{

	//if switch two was pressed, debounce and then clear flag
	if(SW_PxIFG & SW2)
	{
		__delay_cycles(5000);
		FLAGS |= SW2FLAG;
		SW_PxIFG &= ~SW2;
	}
	else if (GDO0_PxIFG & GDO0_PIN)      //SW2
	{
		FLAGS |= GDO0FLAG;
		GDO0_PxIFG &= ~GDO0_PIN;
	}
	LPM3_EXIT;

}
