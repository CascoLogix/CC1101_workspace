

#include <msp430.h> 
#include "CC1101.h"
#include "Pinouts.h"
#include "Registers.h"
#include "debug.h"
#include <stdint.h>
#include <Timer0_A3.h>
#include <Timer1_A3.h>
#include <GPIO.h>
#include <main.h>
#include <USCI.h>


/*
 * main.cpp
 */

/* TODO:
 * - P1.0: LED1 (red)
 * - P1.1: UC0ARXD (input)
 * - P1.2: UCA0TXD (output)
 * - P1.3: SW2 (pushbutton)
 * - P1.4: Use this as pulse input?  Use as gated power to ultrasonic sensor?
 * - P1.5: UCB0CLK (SPI/CLK)
 * - P1.6: UCB0SOMI (SPI/GDO1/MISO)
 * - P1.7: UCB0SIMO (SPI/MOSI)
 * - P2.0: TA1.0 (buzzer)
 * - P2.1: Use this as pulse input?  Use as gated power to ultrasonic sensor?
 * - P2.2: (SPI/CSn)
 * - P2.3: (GDO0)
 * - P2.4: (GDO2)
 * - P2.5: Use this as pulse input?  Use as gated power to ultrasonic sensor?
 * - P2.6: 32.768kHz Crystal
 * - P2.7: 32.768kHz Crystal
*/

#define SW2FLAG 		0x01			//flag for SW2 being pressed
#define GDO0FLAG		0x02			//flag for GDO0 (running in nIRQ mode) pin going low


char txBuffer[4];
char rxBuffer[4];
unsigned char FLAGS = 0;   //char to hold flags generated by ISR
unsigned int i;


enum {
	STATE_UNUSED,
	STATE_IDLE,
	STATE_TRANSMIT,
	STATE_RECEIVE
};


void One_Shot (void);
void TA0CCR1_ISR_Handler (void);
void APP_GPIO_init (void);
void APP_POST (void);
void SW2_callback (void);
void GDO0_callback (void);


void main(void)
{
    WDTCTL = WDTPW | WDTHOLD;	// Stop watchdog timer

    gpio_port1_init();
    gpio_port2_init();
    APP_GPIO_init();
    Timer0_init();
    Timer1_init();

    USCI_A0_init_UART(9600, USCI_A0_CLK_SRC_SMCLK);

	GPIO_PORT1_registerCallback(SW2_PIN_NUM, &SW2_callback, LPM3_bits);		// Should toggle the LED when the button is pressed.
	GPIO_PORT2_registerCallback(GDO0_PIN_NUM, &GDO0_callback, LPM3_bits);
	//Timer0_A1_registerCallback (1, &TA0CCR1_ISR_Handler);

	//UARTInit();					// For debug purposes
    CC1101_init();				// Initialize CC1101
    APP_POST();					// Last step before setting CC1101 to eceive data
    CC1101_setReceive();		// Set CC1101 to receive data

	uint8_t volatile STATE = STATE_IDLE;	// Default state is STATE_IDLE

	while(1)
	{
	    switch(STATE)
		{
			case STATE_IDLE:				// this is the idle state
			{
				__bis_SR_register(LPM3_bits + GIE);

				if(FLAGS & SW2FLAG)
				{
					STATE = STATE_TRANSMIT;
					FLAGS &= ~SW2FLAG;
				}

				else if (FLAGS & GDO0FLAG)
				{
					STATE = STATE_RECEIVE;
					FLAGS &= ~GDO0FLAG;
				}

				_NOP();

				break;
			}

			case STATE_TRANSMIT:
			{
				//temporarily disable GDO0 interrupt
				GDO0_PxIE &= ~GDO0_PIN;

				char size = 3;				// this is the size of the entire packet being sent, including the size byte
				txBuffer[0] = 2;			// this is the size byte (it lets the receiver know how many bytes are following)
				txBuffer[1] = 0x01;			// first byte
				txBuffer[2] = 0xAA;			// second byte
				CC1101_sendPacket(txBuffer, size);
				STATE = STATE_IDLE;			// return to IDLE state
				GDO0_PxIFG &= ~GDO0_PIN;	// Clear flag
				GDO0_PxIE |= GDO0_PIN;		// Enable int on end of packet
				FLAGS = 0;					// clear flag buffer
				break;
			}

			case STATE_RECEIVE:
			{
				//temporarily disable GDO0 interrupt
				GDO0_PxIE &= ~GDO0_PIN;
				char len = 4;

				if(CC1101_receivePacket(rxBuffer, &len))
				{
					short s = CC1101_getRSSI();
					LED1_PxOUT ^= LED1_PIN;
					CC1101_setReceive();
				}

				else
				{
					//CRC did not check out or buffer was too small to hold received packet
				}

				STATE = STATE_IDLE;				// return to idle state
				GDO0_PxIFG &= ~GDO0_PIN;		// Clear flag
				GDO0_PxIE |= GDO0_PIN;			// Enable int on end of packet
				FLAGS = 0;						// clear flag buffer
				break;
			}

			default:
			{
				STATE = STATE_IDLE;				// return to IDLE state
				break;
			}
		}
	}
}


void One_Shot (void)
{
	//GPIO_PORT1.interrupt_enable &= ~SW2_PIN;	// Disable interrupt
	//Timer0_armOneShot(25000, 1);				// Should cause a 200mS blink

	// TODO:
	// - replace with a function call to Timer1_A3 library
	//TA1CCR0 = 121;								// Set compare 0 register to set frequency

	// TODO: Merge below code into code above
}


void SW2_callback (void)
{
	FLAGS |= SW2FLAG;
	LED1_PxOUT |= LED1_PIN; 				// Toggle LED1
    if(!USCI_A0_UART_read_busy_flag())
    {
    	USCI_A0_UART_write_TX_buffer('S');
    }
}


void GDO0_callback (void)
{
	FLAGS |= GDO0FLAG;
	LED1_PxOUT &= ~LED1_PIN; 				// Toggle LED1
    if(!USCI_A0_UART_read_busy_flag())
    {
    	USCI_A0_UART_write_TX_buffer('G');
    }
}


void TA0CCR1_ISR_Handler (void)
{
	//GPIO_PORT1.interrupt_enable |= SW2_PIN;		// Enable P1.3 pin interrupt
	//TA0CCTL1 &= ~CCIE;							// Disable TA0CCR1 interrupt

	// TODO:
	// - replace with a function call to Timer1_A3 library
	//TA1CCR0 = 0;								// Set compare 0 register to turn off tone
}


void APP_GPIO_init (void)
{
	SW2_PxOUT = SW2_PIN;						// Set S2 pin out register for pullup

    // P1.6 is used for SPI, so can't use LED2
	//LED2_PxDIR |= LED2_PIN;						// Set LED pin to output mode
	//LED2_PxSEL = LED2_PIN;						// Select TA0.1 pin function
	//LED2_PxSEL2 = 0;							// Select TA0.1 pin function

	BUZZ_PxDIR = BUZZ_PIN;						// Set buzzer pin to output mode
	BUZZ_PxSEL = BUZZ_PIN;						// Select TA1.0
	BUZZ_PxSEL2 = 0;

    //Configure ports -- switch inputs, LEDs, GDO0 to RX packet info from CC1101
    SW2_PxREN |= SW2_PIN;						// enable pullup/pulldown resistor
    SW2_PxOUT |= SW2_PIN;						// pullup the resistor
    SW2_PxDIR &= ~SW2_PIN;						// set direction as input
    SW2_PxIES |= SW2_PIN;						// Int on falling edge
    SW2_PxIFG &= ~(SW2_PIN);					// Clr flags
    SW2_PxIE = SW2_PIN;							// Activate enables

    LED1_PxDIR |= LED1_PIN;						// set led1 to output

    // P1.6 is used for SPI, so can't use LED2
    //LED2_PxDIR |= LED2_PIN;						// set led2 to output

    GDO0_PxIES |= GDO0_PIN;						// Int on falling edge (end of pkt)
    GDO0_PxREN |= GDO0_PIN;						// enable pullup/pulldown resistor
    GDO0_PxOUT |= GDO0_PIN;						// now pull resistor up
    GDO0_PxIFG &= ~GDO0_PIN;					// Clear flag
    GDO0_PxIE |= GDO0_PIN;						// Enable int on end of packet
}


void APP_POST (void)
{
    volatile uint16_t delayCount;
    volatile uint16_t toggleCount;

    TA1CCR0 = 121;								// Set compare 0 register to start tone

    while(USCI_A0_UART_read_busy_flag());
   	USCI_A0_UART_write_TX_buffer('R');			// Send 'R' for reset
   	while(USCI_A0_UART_read_busy_flag());
	USCI_A0_UART_write_TX_buffer(0x0D);			// Send <CR> for reset
   	while(USCI_A0_UART_read_busy_flag());
	USCI_A0_UART_write_TX_buffer(0x0A);			// Send <LF> for reset

    LED1_PxOUT &= ~LED1_PIN; 					// Set LED1 off

    for(toggleCount = 0; toggleCount < 8; toggleCount++)
    {
		LED1_PxOUT ^= LED1_PIN; 				// Toggle LED1
		for(delayCount = 0; delayCount < 10000; delayCount++);
    }

    TA1CCR0 = 0;								// Clear compare 0 register to stop tone
}

